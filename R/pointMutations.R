

#' Split filtered_feature_bc.csv file to individual spots.
#'
#' @param file filtered_feature_bc.csv from spaceranger
#'
#' @importFrom stringi stri_pad_left
#' @importFrom futile.logger flog.info
#' @importFrom futile.logger flog.warn
#'
#' @return Two folders of txt files, spot barcodes and spot gene exp profile
#' @export
#'
#' @examples \dontrun{
#' print("check user guide")
#' }
splitSpot <- function(file) {
  if (!file.exists("spatial/spotIndex")) {
    flog.info("Creating folders: spatial/spotIndex")
    dir.create("spatial/spotIndex", recursive = TRUE)
  } else {
    flog.warn("The path 'spatial/spotIndex' exists, please clean your working directory and restart.")
    stop("File pathes conflicts")
  }

  if (!file.exists("spatial/txt")) {
    flog.info("Creating folders: spatial/txt")
    dir.create("spatial/txt", recursive = TRUE)
  } else {
    flog.warn("The path 'spatial/txt' exists, please clean your working directory and restart.")
    stop("File pathes conflicts")
  }

  if ((ncol(file) - 1) < 1000) {
    flog.info("It has less than 1000 spots. The first spot is named spot000")
    n <- 3
  } else {
    flog.info("It has >= 1000 spots. The first spot is named spot00..00")
    n <- nchar(ncol(file) - 1)
  }

  for (i in 2:ncol(file)) {
    data <- file[, c(1, i)]
    idx <- stri_pad_left(i - 2, n, 0)
    barcode <- names(data)[2]
    barcode <- stringr::str_replace(barcode, ".1", "-1")
    write.table(barcode, file = paste0("./spatial/spotIndex/spot", idx, ".txt"), row.names = FALSE, col.names = FALSE, quote = FALSE)
    write.table(data, file = paste0("./spatial/txt/spot", idx, ".txt"), quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
  }
}


#' Visualize Somatic Alterations of fresh frozen Spatial Transcriptomics Data
#'
#' @param files A vector containing file path of spatial barcode txt files
#' @param data1 filtered_feature_bc.csv generated by spaceranger
#' @param data2 Graph-Based csv file exported from 10X Loupe Browser when open Loupe.Loupe
#' @param path Path to the tissue_positions_list.csv under spatial/ folder
#'
#' @importFrom stringr str_replace str_split
#' @importFrom dplyr filter %>%
#' @importFrom utils read.csv read.table
#' @importFrom futile.logger flog.error
#'
#' @return A list of two dataframe, the first dataframe includes spot-barcode-reads,
#' the second dataframe is used for grouping spots if necessary.
#' @export
#'
#' @examples \dontrun{
#' files <- list.files(
#'   path = system.file("extdata/spotIndex", package = "stmut"),
#'   pattern = ".txt", full.names = TRUE, recursive = FALSE
#' )
#' data1 <- read.csv(system.file("extdata/", "filtered_feature_bc.csv",
#'   package = "stmut"
#' ), header = TRUE)
#' data2 <- read.csv(system.file("extdata/", "Graph-Based.csv", package = "stmut"), header = TRUE)
#' path <- system.file("extdata/", "tissue_positions_list.csv", package = "stmut")
#' df <- sptBClstRds(files = files, data1 = data1, data2 = data2, path = path)
#' }
sptBClstRds <- function(files, data1, data2, path) {
  ## check inputs
  if (is.null(files)) {
    flog.error("files is empty!!")
    stop("The length of files must be equal to the number of spots!")
  } else if (length(files) != nrow(data2)) {
    stop("The length of files must be equal to the number of spots!")
  }

  stopifnot(is.character(files), is.data.frame(data1), is.data.frame(data2), is.character(path))

  # make sure the number of spots in each input is consistent.
  n1 <- length(names(data1)) - 1
  n2 <- length(files)
  n3 <- nrow(data2)
  if (n1 == n2 & n2 == n3) {
    barcode <- NULL # this code to avoid the note "no visible binding for global variable ‘barcode’"
    nrow <- length(colnames(data1)[-1])

    # Count total reads of each spot
    data1 <- data1[, -1]
    df0 <- data.frame(colnames(data1), colSums(data1)) # spotBcode and total reads of each spot
    colnames(df0) <- c("barcode", "TotalRDs")
    df0$barcode <- str_replace(df0$barcode, ".1", "-1")
    df1 <- data.frame(matrix(nrow = nrow, ncol = 2))
    lapply(files, function(x) {
      tab <- read.table(x, sep = "\t", header = FALSE)
      spts <- str_split(x, "/", simplify = TRUE)
      spts <- str_split(x, "/", simplify = TRUE)[length(spts)]
      sptn <- substr(spts, 1, (nchar(spts) - 4))
      i <- as.numeric(substr(sptn, 5, nchar(spts))) + 1
      df1[i, 1] <<- tab[1, 1]
      df1[i, 2] <<- sptn
    })
    colnames(df1) <- c("barcode", "spot")
    df1 <- merge(df1, df0, by = "barcode")

    # generate barcode-spotName-cluster dataframe
    colnames(data2) <- c("barcode", "cluster")
    df2 <- merge(data2, df1, by = "barcode")

    # add spot coordinates
    spotloc <- read.csv(path, header = FALSE)
    colnames(spotloc) <- c("barcode", "in_tissue", "array_row", "array_col", "pxl_row_in_fullres", "pxl_col_in_fullres")
    spotloc <- spotloc[, c(1, 3, 4)]
    spotloc <- spotloc %>% filter(barcode %in% df2$barcode)
    df2 <- merge(df2, spotloc, by = "barcode")
    returnList <- list(df1, df2)
    return(returnList)
  } else {
    flog.error("The number of spots in all inputs files are not consistent!!")
    stop("Check the number of spots in each input file!!")
  }
}


#' Count Ref and Mutant Reads for Each Spot
#'
#' @param index A Dataframe of spatial barcode
#' @param files Vector of paths of samtools Mpileup output of each spot
#'
#' @importFrom utils read.delim
#' @importFrom futile.logger flog.error
#'
#' @return A list of two dataframe
#' @export
#'
#' @examples \dontrun{
#' index <- read.csv(system.file("extdata/", "spotBC.csv", package = "stmut"), header = TRUE)
#' files2 <- list.files(
#'   path = system.file("extdata/mpileup", package = "stmut"),
#'   pattern = "MpileupOutput_RNA.txt", full.names = TRUE, recursive = TRUE, include.dirs = TRUE
#' )
#' df1 <- sptMutCt(index = index, files = files2)
#' }
#'
sptMutCt <- function(index, files) {
  if (is.null(files)) {
    flog.error("files is empty")
    stop("files are a list of paths of the spot point mutations counts, generated by 'samtools mpeleup'!")
  } else if (length(files) < nrow(index)) {
    flog.error("the number of spot paths and the number of spots in index dataframe are not consistent.")
    stop("The number of spots in inputs are not consistent.")
  }

  stopifnot(is.character(files), is.data.frame(index))
  Rcount <- NULL

  spotC <- function(x) {
    # extract spot name
    sptNs <- str_split(x, "/", simplify = TRUE)
    idx <- pmatch("spot", sptNs) # partial match
    sptN <- sptNs[idx]
    i <- as.numeric(substr(sptN, 5, nchar(sptN))) + 1 # the number of spot;spot name starts with 0000, r start with 1

    # read the Mpileup file
    spot <- read.delim(x, header = FALSE, sep = "\t", quote = "")
    spot[1, 9] <- "Rcount"
    spot[1, 10] <- "Mcount"
    cn <- spot[1, ] # extract column name
    spt <- spot[-1, ]
    colnames(spt) <- cn
    spt <- spt[, c(9, 10)]
    df <- spt %>%
      filter(!Rcount == "Manually Inspect") %>%
      filter(!Rcount == "Manually Inspect")
    df$Rcount <- as.numeric(df$Rcount)
    df$Mcount <- as.numeric(df$Mcount)

    a <- sum(df$Rcount)
    b <- sum(df$Mcount)

    # add group name for Loupe browser
    if (b == 0) {
      c <- "G0"
    } else if (b == 1) {
      c <- "G1"
    } else if (b == 2) {
      c <- "G2"
    } else if (b == 3) {
      c <- "G3"
    } else if (b == 4) {
      c <- "G4"
    } else if (b == 5) {
      c <- "G5"
    } else if (b == 6) {
      c <- "G6"
    } else if (b == 7) {
      c <- "G7"
    } else if (b == 8) {
      c <- "G8"
    } else if (b == 9) {
      c <- "G9"
    } else {
      c <- "G10"
    }

    spotVec <- c(sptN, a, b, a + b, c, index[which(index$spot == sptN), 1])
    return(spotVec)
  }

  f1 <- parallel::mclapply(files, function(x) {
    d1 <- spotC(x)
  }, mc.cores = 3)
  f2 <- data.frame(do.call("rbind", f1))
  colnames(f2) <- c("spot", "RreadC", "MreadC", "Treads", "groups", "barcode")
  f2$RreadC <- as.numeric(f2$RreadC)
  f2$MreadC <- as.numeric(f2$MreadC)
  f2$Treads <- as.numeric(f2$Treads)
  final <- f2[order(f2$MreadC, decreasing = TRUE), ]
  LoupeFile <- final[, c(6, 5)]
  colnames(LoupeFile) <- c("index", "groups")
  returnList <- list(final, LoupeFile)
}


#' Generate Non-zero Reads Spot Comprehensive Table
#'
#' @param df1 first input: spotBClsterRds.csv
#' @param df2 second input: spotRdCtFinal.csv
#'
#' @importFrom futile.logger flog.error
#'
#' @return  A list of two dataframes
#' @export
#'
#' @examples \dontrun{
#' d1 <- read.csv(system.file("extdata/", "spotBClster.csv", package = "stmut"), header = TRUE)
#' d2 <- read.csv(system.file("extdata/", "spotRdCtFinal.csv", package = "stmut"), header = TRUE)
#' df3 <- nonZeRdCts(df1 = d1, df2 = d2)
#' }
nonZeRdCts <- function(df1, df2) {
  if (!is.data.frame(df1) | !is.data.frame(df2)) {
    flog.error("df1 and df2 must be dataframe!!")
    stop("One of the inputs is not data frame!!")
  }

  if (nrow(df1) != nrow(df2)) {
    flog.error("Input files conflict!!")
    stop("Spot numbers of the inputs are not consistent!!")
  }

  MreadC <- NULL
  Treads <- NULL
  df <- merge(df1, df2, by = c("barcode", "spot"))
  df3 <- df %>% filter(Treads != 0) # filter out spots with 0 reads
  df4 <- df %>% filter(MreadC != 0) # keep spots with mutant reads
  returnList <- list(df3, df4)
  return(returnList)
}


#' Rank Spots with Mutant Reads using A Customized Strategy
#'
#' @param df A dataframe of nonZeroRdSpotIndex.csv
#' @param path1 A path to where spot mutant reads statistic file is located
#'
#' @importFrom futile.logger flog.error
#'
#' @return A comprehensive table mutant information of each spot
#' @export
#'
#' @examples \dontrun{
#' df <- read.csv(system.file("extdata/", "NonZeroRdSpotIndex.csv", package = "stmut"), header = TRUE)
#' path1 <- system.file("extdata/mpileup", package = "stmut")
#' df4 <- spotSummary(df = df, path1 = path1)
#' }
spotSummary <- function(df, path1) {
  if (!is.data.frame(df)) {
    flog.error("df is not a data frame!!")
    stop("df should be a data frame!")
  }

  MreadC <- NULL
  mutCt <- NULL
  propM2Total <- df$MreadC / df$TotalRDs * 10000 # add first variable
  propM2SumRM <- df$MreadC / df$Treads # add second variable
  MoreThan1Mrd <- rep(0, dim(df)[1])
  Score <- rep(0, dim(df)[1])
  df <- cbind(df, propM2Total, propM2SumRM, MoreThan1Mrd, Score)

  # add third variable, give a bonus for spot with more than one mutant read
  for (j in 1:dim(df)[1]) {
    if (df[j, "MreadC"] > 1) {
      df[j, "MoreThan1Mrd"] <- 1
      df[j, "Score"] <- df[j, "propM2Total"] + df[j, "MoreThan1Mrd"] # add third variable
    } else {
      df[j, "MoreThan1Mrd"] <- 0
      df[j, "Score"] <- df[j, "propM2Total"] + df[j, "MoreThan1Mrd"]
    }
  }

  # extract gene names that containing mutant reads
  data <- df

  for (sp in data$spot) { # add mutant read gene names
    p <- paste0(path1, sp, "/MpileupOutput_RNA.txt")
    mpilp <- read.delim(p, header = FALSE, sep = "\t", quote = "")
    mpilp[1, 9] <- "refCt"
    mpilp[1, 10] <- "mutCt"
    colnames(mpilp) <- mpilp[1, ]
    mpilp <- mpilp[-1, ]
    mpilpMut <- mpilp %>% filter(!(mutCt == "0" | mutCt == "Manually Inspect"))

    GenesWithMutRead <- ""
    for (i in 1:dim(mpilpMut)[1]) {
      GenesWithMutRead <- paste0(GenesWithMutRead, mpilpMut[i, 1], "-", mpilpMut[i, 2], ":", mpilpMut[i, 3], " ", mpilpMut[i, 5], ">", mpilpMut[i, 6], ";")
    }
    data[which(data$spot == sp), "GenesWithMutRead"] <- GenesWithMutRead
  }

  data <- data[order(data$Score, decreasing = TRUE), ] # higher the score, much likely the tumor spots
  data <- data %>% filter(MreadC > 0)
  return(data)
}



#' Generate new spot-groups based on the number of mut and ref reads(the spots having
#' more mutant reads are more likely to have tumor cells/spots) for loupe visualization.
#'
#' @param data1 A dataframe of MutantSpotIndex_scored.csv, which is the output of spotSummary func.
#' @param data2 A df of barcode, which is the first output of the sptBClstRds func.
#'
#' @importFrom futile.logger flog.error
#'
#' @return A df for Loupe visualization of AllSptTumPropsed.csv
#' @export
#'
#' @examples \dontrun{
#' print("check user guider")
#' }
proposTumLoup <- function(data1, data2) {
  if (!is.data.frame(data1)) {
    flog.error("data1 is not a data frame!")
    stop("data1 is not a data frame!")
  }
  if (!is.data.frame(data2)) {
    flog.error("data2 is not a data frame!")
    stop("data2 is not a data frame!")
  }


  TumorGp <- rep(0, dim(data1)[1])
  data <- cbind(data1, TumorGp)

  for (i in 1:dim(data)[1]) {
    if (data[i, "MreadC"] >= 2) {
      data[i, "TumorGp"] <- "2+Mut"
    } else if (data[i, "MreadC"] == 1) {
      data[i, "TumorGp"] <- "1Mut"
    } else if (data[i, "MreadC"] == 0 & data[i, "RreadC"] == 1) {
      data[i, "TumorGp"] <- "0Mut1Ref"
    } else if (data[i, "MreadC"] == 0 & data[i, "RreadC"] == 2) {
      data[i, "TumorGp"] <- "0Mut2Ref"
    } else if (data[i, "MreadC"] == 0 & data[i, "RreadC"] == 3) {
      data[i, "TumorGp"] <- "0Mut3Ref"
    } else if (data[i, "MreadC"] == 0 & data[i, "RreadC"] == 4) {
      data[i, "TumorGp"] <- "0Mut4Ref"
    } else {
      data[i, "TumorGp"] <- "0Mut5+Ref"
    }
  }

  subData <- data[, c("barcode", "TumorGp")]

  # add unassigned spots as "G0=0Mut0Ref", better for visualization
  barcode <- (data2 %>% filter(!barcode %in% subData$barcode))[, 1]
  TumorGp <- rep("0Mut0Ref", length(barcode))
  unasspots <- data.frame(barcode, TumorGp)
  colnames(subData) <- names(unasspots)
  finalD <- rbind(subData, unasspots)
  return(finalD)
}


#' Generate combined spatial spot point mutations list.
#'
#' @param files1 A list of spotIndex files
#' @param files2 A list of spot mutation list files, samtools mpileup output
#' @param data1 filtered_feature_bc_.csv, output of spaceranger pipeline
#' @param data2 Graph-based.csv
#' @param path path of tissue_positions_list.csv
#' @param path1 path of mpileup outputs
#'
#' @importFrom futile.logger flog.error
#' @importFrom futile.logger flog.info
#'
#' @return A pointMutation folder includes 8 files,AllSptTumPropsed.csv, spotMutReadCount.csv,
#' MutantSpotIndex.csv, spotRdCtFinal.csv, NonZeroRdSpotIndex.csv, sptBcRds.csv,
#' MutantSpotIndex_Scored.csv, sptBcSummary.csv
#' @export
#'
#' @examples \dontrun{
#' print("check user guide")
#' }
spaPointMutation <- function(files1, files2, data1, data2, path, path1) {
  if (!file.exists("PointMutation")) {
    flog.info("Creating folder: ./PointMutation in your working directory!")
    dir.create("./PointMutation", recursive = TRUE)
  } else {
    flog.error("Folder 'PointMutation' exists!")
    stop("Please clean your folder and rerun the codes!")
  }

  n1 <- length(files1)
  n2 <- ncol(data1) - 1
  n3 <- nrow(data2)
  n4 <- length(files2)

  if (n1 == n2 && n2 == n3 && n3 == n4) {
    step_count <- 1
    flog.info(paste0("Step ", step_count, ": Generating spots summary files,sptBcRds.csv and sptBcSummary.csv; counting the total reads of each spot!"))

    p <- getwd()
    df1 <- sptBClstRds(files1, data1, data2, path)
    write.csv(df1[[1]], file = paste0(p, "/PointMutation/sptBcRds.csv"), row.names = FALSE)
    write.csv(df1[[2]], file = paste0(p, "/PointMutation/sptBcSummary.csv"), row.names = FALSE)

    step_count <- step_count + 1
    flog.info(paste0("Step ", step_count, ": Count point mutations for each spot; Generate 2 files: spotRdCtFinal.csv and spotMutReadCount.csv"))
    index <- df1[[1]]
    df2 <- sptMutCt(index, files2)
    write.csv(df2[[1]], file = paste0(p, "/PointMutation/spotRdCtFinal.csv"), row.names = FALSE)
    write.csv(df2[[2]], file = paste0(p, "/PointMutation/spotMutReadCount.csv"), row.names = FALSE)

    step_count <- step_count + 1
    flog.info(paste0("Step ", step_count, ": Count point mutations for each spot; Generate 2 files: NonZeroRdSpotIndex.csv and MutantSpotIndex.csv; Removing spots with 0 reads and spots with 0 mutant reads!"))
    d1 <- df1[[2]]
    d2 <- df2[[1]]
    df3 <- nonZeRdCts(d1, d2)
    write.csv(df3[[1]], file = paste0(p, "/PointMutation/NonZeroRdSpotIndex.csv"), row.names = FALSE) # remove TreadC == 0
    if (dim(df3[[2]])[1] == 0) {
      flog.info("0 mutant reads are detected in all spots or cells.")
    } else {
      write.csv(df3[[2]], file = paste0(p, "/PointMutation/MutantSpotIndex.csv"), row.names = FALSE) # remove MreadC == 0
    }

    step_count <- step_count + 1
    flog.info(paste0("Step ", step_count, ": Generate MutantSpotIndex_Scored.csv and AllSptTumPropsed.csv; The latter is for 10x Loupe Visualization of spots containing point mutations!"))
    d3 <- df3[[1]] # NonZeroRdSpotIndex
    df4 <- spotSummary(d3, path1) # MutantSpotIndex_Scored
    if (dim(df4)[1] == 0) {
      flog.info("0 mutant reads are detected in all spots or cells. The MutantSpotIndex_Scored.csv is not generated.")
    } else {
      write.csv(df4, file = paste0(p, "/PointMutation/MutantSpotIndex_Scored.csv"), row.names = FALSE)
    }
    df5 <- proposTumLoup(df3[[1]], df1[[2]]) # spot point mutation for LoupeBrowser visualization.
    write.csv(df5, file = paste0(p, "/PointMutation/AllSptTumPropsed.csv"), row.names = FALSE)
  } else {
    flog.error("One of the inputs has different number of spots")
    stop("Please make sure all inputs have the same number of spots or cells!!")
  }
}



splitSpot1 <- function(file) {
  if (!file.exists("CNVs/spotIndex")) {
    flog.info("Creating folders: CNVs/spotIndex")
    dir.create("CNVs/spotIndex", recursive = TRUE)
  } else {
    flog.warn("The path 'CNVs/spotIndex' exists, please clean your working directory and restart.")
    stop("File pathes conflicts")
  }

  if (!file.exists("CNVs/txt")) {
    flog.info("Creating folders: CNVs/txt")
    dir.create("CNVs/txt", recursive = TRUE)
  } else {
    flog.warn("The path 'CNVs/txt' exists, please clean your working directory and restart.")
    stop("File pathes conflicts")
  }

  if ((ncol(file) - 1) < 1000) {
    flog.info("It has less than 1000 spots. The first spot is named spot000")
    n <- 3
  } else {
    flog.info("It has >= 1000 spots. The first spot is named spot00..00")
    n <- nchar(ncol(file) - 1)
  }

  for (i in 2:ncol(file)) {
    data <- file[, c(1, i)]
    # idx <- stri_pad_left(i - 2, n, 0)
    idx <- i -1
    barcode <- names(data)[2]
    barcode <- stringr::str_replace(barcode, "\\.1", "-1")
    write.table(barcode, file = paste0("./CNVs/spotIndex/spot", idx, ".txt"), row.names = FALSE, col.names = FALSE, quote = FALSE)
    write.table(data, file = paste0("./CNVs/txt/spot", idx, ".txt"), quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
  }
}
